/**
 * Component: UpdateTargetSelector
 * ────────────────────────────────────────────────────────────────
 *
 * Purpose:
 *  - Drill-down selector for update targets
 *  - Forces contributor to select the exact blueprint context
 *    before uploading a YAML
 *
 * Canonical order (LOCKED):
 *  Category
 *   → Blueprint ID
 *     → Library ID
 *       → Release ID
 *         → Version
 *
 * Filesystem truth (LOCKED):
 *  ./<category>/<blueprint>/<library>/<release>/<version>/<blueprint>.yaml
 *
 * Scope:
 *  - Phase A only
 *  - No guessing
 *  - No heuristics
 */
import React, { useMemo } from 'react'
import { blueprintsContext } from '../../utils/libraryContexts'

export interface UpdateTarget {
  category: string
  blueprintId: string
  libraryId: string
  releaseId: string
  version: string
}

interface Props {
  value: UpdateTarget | null
  onChange: (target: UpdateTarget | null) => void
}

/**
 * Parse YAML paths ONLY.
 * Filename is ignored by design.
 */
function parseBlueprintPaths() {
  return blueprintsContext.keys().map((key) => {
    const parts = key.replace(/^\.\//, '').split('/')

    // Guard: require full depth INCLUDING filename
    if (parts.length < 6) return null

    return {
      category: parts[0],
      blueprintId: parts[1],
      libraryId: parts[2],
      releaseId: parts[3],
      version: parts[4],
    }
  }).filter(Boolean) as UpdateTarget[]
}

const UpdateTargetSelector: React.FC<Props> = ({ value, onChange }) => {
  const entries = useMemo(parseBlueprintPaths, [])

  const categories = useMemo(
    () => Array.from(new Set(entries.map((e) => e.category))).sort(),
    [entries],
  )

  const blueprints = useMemo(() => {
    if (!value?.category) return []
    return Array.from(
      new Set(
        entries
          .filter((e) => e.category === value.category)
          .map((e) => e.blueprintId),
      ),
    ).sort()
  }, [entries, value?.category])

  const libraries = useMemo(() => {
    if (!value?.category || !value?.blueprintId) return []
    return Array.from(
      new Set(
        entries
          .filter(
            (e) =>
              e.category === value.category &&
              e.blueprintId === value.blueprintId,
          )
          .map((e) => e.libraryId),
      ),
    ).sort()
  }, [entries, value?.category, value?.blueprintId])

  const releases = useMemo(() => {
    if (!value?.category || !value?.blueprintId || !value?.libraryId) return []
    return Array.from(
      new Set(
        entries
          .filter(
            (e) =>
              e.category === value.category &&
              e.blueprintId === value.blueprintId &&
              e.libraryId === value.libraryId,
          )
          .map((e) => e.releaseId),
      ),
    ).sort()
  }, [entries, value?.category, value?.blueprintId, value?.libraryId])

  const versions = useMemo(() => {
    if (
      !value?.category ||
      !value?.blueprintId ||
      !value?.libraryId ||
      !value?.releaseId
    )
      return []

    return Array.from(
      new Set(
        entries
          .filter(
            (e) =>
              e.category === value.category &&
              e.blueprintId === value.blueprintId &&
              e.libraryId === value.libraryId &&
              e.releaseId === value.releaseId,
          )
          .map((e) => e.version),
      ),
    ).sort()
  }, [
    entries,
    value?.category,
    value?.blueprintId,
    value?.libraryId,
    value?.releaseId,
  ])

return (
  <div className='contributorsSection'>
    <div className='card'>
      <div className='card__body'>
        <h3>Select update target</h3>

	<div className="updateTargetRow">
	  <select
	    value={value?.category ?? ''}
	    onChange={(e) =>
	      onChange(
	        e.target.value
	          ? {
	              category: e.target.value,
	              blueprintId: '',
	              libraryId: '',
	              releaseId: '',
	              version: '',
	            }
	          : null,
	      )
	    }
	  >
	    <option value=''>Category…</option>
	    {categories.map((c) => (
	      <option key={c} value={c}>{c}</option>
	    ))}
	  </select>

	  <select
	    disabled={!value?.category}
	    value={value?.blueprintId ?? ''}
	    onChange={(e) =>
	      onChange({
	        category: value!.category,
	        blueprintId: e.target.value,
	        libraryId: '',
	        releaseId: '',
	        version: '',
	      })
	    }
	  >
	    <option value=''>Blueprint…</option>
	    {blueprints.map((b) => (
	      <option key={b} value={b}>{b}</option>
	    ))}
	  </select>

	  <select
	    disabled={!value?.blueprintId}
	    value={value?.libraryId ?? ''}
	    onChange={(e) =>
	      onChange({
	        ...value!,
	        libraryId: e.target.value,
	        releaseId: '',
	        version: '',
	      })
	    }
	  >
	    <option value=''>Library…</option>
	    {libraries.map((l) => (
	      <option key={l} value={l}>{l}</option>
	    ))}
	  </select>

	  <select
	    disabled={!value?.libraryId}
	    value={value?.releaseId ?? ''}
	    onChange={(e) =>
	      onChange({
	        ...value!,
	        releaseId: e.target.value,
	        version: '',
	      })
	    }
	  >
	    <option value=''>Release…</option>
	    {releases.map((r) => (
	      <option key={r} value={r}>{r}</option>
	    ))}
	  </select>

	  <select
	    disabled={!value?.releaseId}
	    value={value?.version ?? ''}
	    onChange={(e) =>
	      onChange({
	        ...value!,
	        version: e.target.value,
	      })
	    }
	  >
	    <option value=''>Version…</option>
	    {versions.map((v) => (
	      <option key={v} value={v}>{v}</option>
	    ))}
	  </select>

	</div>
      </div>
     </div>
    </div>
  )
}

export default UpdateTargetSelector
